# Default values for helm-charts
# This file defines the default values for our Flask application deployment.
# Variables here will be passed into the templates.

# Environment settings
# We define the environment for the app (dev, stage, prod) for flexible deployments.
environment: dev  # Can be dev, stage, or prod

# Domain configuration
# We set up the base domain to easily manage different environments.
baseDomain: flask-app.internal

# Application configuration
# We define the number of replicas for our application.
# By default, we run 1 replica, but we can scale it up for production or high availability.
replicaCount: 1

# Container image configuration
# The image repository, pull policy, and tag can be customized for our deployment.
image:
  repository: r21gh/flask-app  # Using Docker Hub repository
  pullPolicy: Always
  tag: latest

# Application secrets
# These are sensitive variables like keys and passwords that we should securely set.
secrets:
  secretKey: "dev-secret-key"
  dbPassword: "dev-password"

# Environment variables
# We define environment-specific variables for our Flask app.
env:
  apiBaseUrl: "http://dev.flask-app.internal"  # API base URL for dev environment
  logLevel: "INFO"                             # Log level (e.g., DEBUG, INFO, WARN)

# Image pull secrets for private registries
# We use this for pulling images from private container registries.
# More info: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []

# Chart name overrides
# This is useful if we need to change the default name or use a custom name.
nameOverride: ""
fullnameOverride: ""

# Service Account configuration
# Service accounts help us manage permissions and API access for our Pods.
serviceAccount:
  create: true               # Should a new service account be created?
  automount: true            # Automatically mount the service account's API credentials?
  annotations: {}            # Add custom annotations to the service account (e.g., for RBAC)
  name: ""                   # Name of the service account (auto-generated if left blank)

# Pod annotations
# We define custom annotations for our app's routes/endpoints. This is useful for monitoring or documentation.
podAnnotations:
  endpoints.flask.app/root: "Returns a string response"
  endpoints.flask.app/config: "Returns application configuration as JSON"

# Security contexts
# Defines pod-level security settings like file system group and permissions.
podSecurityContext:
  fsGroup: 1000

# Security Context for the container
# We configure how the container should run in terms of security (e.g., non-root user, read-only filesystem).
securityContext:
  capabilities:
    drop:
    - ALL
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  allowPrivilegeEscalation: false

# Service configuration
# This defines how our application is exposed within the Kubernetes cluster.
# More info: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  type: NodePort   # Changed to NodePort for direct access
  port: 8080
  nodePort: 30080  # Fixed NodePort for consistent access

# Resource configuration
# We set CPU and memory limits/requests for our pods. Helps us manage resources in Kubernetes.
resources:
  limits:
    cpu: 200m      # Limit CPU usage to 200m (200 milli-cores)
    memory: 256Mi  # Limit memory usage to 256Mi
  requests:
    cpu: 100m      # Request CPU for pod scheduling (e.g., 100 milli-cores)
    memory: 128Mi  # Request memory for pod scheduling (e.g., 128Mi)

# Additional configurations
# We set node selectors to ensure pods are scheduled on specific nodes based on labels.
nodeSelector: {}

# We allow pods to be scheduled on nodes with specific taints (e.g., dedicated nodes).
tolerations: []

# We use affinity rules to control pod placement on nodes based on various conditions.
affinity: {}
